package com.java.spring.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeanInstantiationException;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.support.*;
import org.springframework.cglib.core.ClassGenerator;
import org.springframework.cglib.core.DefaultGeneratorStrategy;
import org.springframework.cglib.core.SpringNamingPolicy;
import org.springframework.cglib.proxy.*;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/**
 * Default object instantiation strategy for use in BeanFactories.
 *
 * <p>Uses CGLIB to generate subclasses dynamically if methods need to be
 * overridden by the container to implement <em>Method Injection</em>.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 1.1
 */
public class CglibSubclassingInstantiationStrategy extends SimpleInstantiationStrategy {

    /**
     * Index in the CGLIB callback array for passthrough behavior,
     * in which case the subclass won't override the original class.
     */
    private static final int PASSTHROUGH = 0;

    /**
     * Index in the CGLIB callback array for a method that should
     * be overridden to provide <em>method lookup</em>.
     */
    private static final int LOOKUP_OVERRIDE = 1;

    /**
     * Index in the CGLIB callback array for a method that should
     * be overridden using generic <em>method replacer</em> functionality.
     */
    private static final int METHOD_REPLACER = 2;


    @Override
    public Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
        return instantiateWithMethodInjection(bd, beanName, owner, null);
    }

    @Override
    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,
                                                    @Nullable Constructor<?> ctor, Object... args) {

        // Must generate CGLIB subclass...
        // 通过CGLIB生成一个子类对象，进入初始化方法
        return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);
    }


    /**
     * An inner class created for historical reasons to avoid external CGLIB dependency
     * in Spring versions earlier than 3.2.
     */
    private static class CglibSubclassCreator {

        private static final Class<?>[] CALLBACK_TYPES = new Class<?>[]
                {NoOp.class, LookupOverrideMethodInterceptor.class, ReplaceOverrideMethodInterceptor.class};

        private final RootBeanDefinition beanDefinition;

        private final BeanFactory owner;

        CglibSubclassCreator(RootBeanDefinition beanDefinition, BeanFactory owner) {
            this.beanDefinition = beanDefinition;
            this.owner = owner;
        }

        /**
         * Create a new instance of a dynamically generated subclass implementing the
         * required lookups.
         *
         * @param ctor constructor to use. If this is {@code null}, use the
         *             no-arg constructor (no parameterization, or Setter Injection)
         * @param args arguments to use for the constructor.
         *             Ignored if the {@code ctor} parameter is {@code null}.
         * @return new instance of the dynamically generated subclass
         */
        public Object instantiate(@Nullable Constructor<?> ctor, Object... args) {
            // 通过 Cglib 创建一个代理类，为提供的 BeanDefinition 创建 bean 类的增强子类。=======================
            Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
            Object instance;
            // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例
            if (ctor == null) {
                instance = BeanUtils.instantiateClass(subclass);
            } else {
                try {
                    // 获取代理类对应的构造器对象，并实例化 bean
                    Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
                    instance = enhancedSubclassConstructor.newInstance(args);
                } catch (Exception ex) {
                    throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
                            "Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
                }
            }
            // SPR-10785: set callbacks directly on the instance instead of in the
            // enhanced class (via the Enhancer) in order to avoid memory leaks.
            // 为了避免 memory leaks 异常，直接在 bean 实例上设置回调对象
            Factory factory = (Factory) instance;
            factory.setCallbacks(new Callback[]{NoOp.INSTANCE,
                    new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
                    new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
            return instance;
        }

        /**
         * Create an enhanced subclass of the bean class for the provided bean
         * definition, using CGLIB.
         */
        private Class<?> createEnhancedSubclass(RootBeanDefinition beanDefinition) {
            // 创建 Enhancer 对象
            Enhancer enhancer = new Enhancer();
            // 设置 Bean 类
            enhancer.setSuperclass(beanDefinition.getBeanClass());
            // 设置 Spring 的命名策略
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            // 设置生成策略
            if (this.owner instanceof ConfigurableBeanFactory) {
                ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader();
                enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));
            }
            // 过滤，自定义逻辑来指定调用的callback下标 ===========================
            //MethodOverrideCallbackFilter 是用来定义 CGLIB 回调过滤方法的拦截器行为，它继承 CglibIdentitySupport 实现 CallbackFilter 接口。
            //CallbackFilter 是 CGLIB 的一个回调过滤器。
            //CglibIdentitySupport 则为 CGLIB 提供 #hashCode() 和 #equals(Object o) 方法，以确保 CGLIB 不会为每个 Bean 生成不同的类。
            //MethodOverrideCallbackFilter 实现 CallbackFilter 的 #accept(Method method) 方法，
            enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));
            enhancer.setCallbackTypes(CALLBACK_TYPES);
            return enhancer.createClass();
        }
    }


    /**
     * Class providing hashCode and equals methods required by CGLIB to
     * ensure that CGLIB doesn't generate a distinct class per bean.
     * Identity is based on class and bean definition.
     */
    private static class CglibIdentitySupport {

        private final RootBeanDefinition beanDefinition;

        public CglibIdentitySupport(RootBeanDefinition beanDefinition) {
            this.beanDefinition = beanDefinition;
        }

        public RootBeanDefinition getBeanDefinition() {
            return this.beanDefinition;
        }

        @Override
        public boolean equals(Object other) {
            return (getClass() == other.getClass() &&
                    this.beanDefinition.equals(((CglibIdentitySupport) other).beanDefinition));
        }

        @Override
        public int hashCode() {
            return this.beanDefinition.hashCode();
        }
    }


    /**
     * CGLIB GeneratorStrategy variant which exposes the application ClassLoader
     * as thread context ClassLoader for the time of class generation
     * (in order for ASM to pick it up when doing common superclass resolution).
     */
    private static class ClassLoaderAwareGeneratorStrategy extends DefaultGeneratorStrategy {

        @Nullable
        private final ClassLoader classLoader;

        public ClassLoaderAwareGeneratorStrategy(@Nullable ClassLoader classLoader) {
            this.classLoader = classLoader;
        }

        @Override
        public byte[] generate(ClassGenerator cg) throws Exception {
            if (this.classLoader == null) {
                return super.generate(cg);
            }

            Thread currentThread = Thread.currentThread();
            ClassLoader threadContextClassLoader;
            try {
                threadContextClassLoader = currentThread.getContextClassLoader();
            } catch (Throwable ex) {
                // Cannot access thread context ClassLoader - falling back...
                return super.generate(cg);
            }

            boolean overrideClassLoader = !this.classLoader.equals(threadContextClassLoader);
            if (overrideClassLoader) {
                currentThread.setContextClassLoader(this.classLoader);
            }
            try {
                return super.generate(cg);
            } finally {
                if (overrideClassLoader) {
                    // Reset original thread context ClassLoader.
                    currentThread.setContextClassLoader(threadContextClassLoader);
                }
            }
        }
    }


    /**
     * CGLIB callback for filtering method interception behavior.
     */
    private static class MethodOverrideCallbackFilter extends CglibIdentitySupport implements CallbackFilter {

        private static final Log logger = LogFactory.getLog(MethodOverrideCallbackFilter.class);

        public MethodOverrideCallbackFilter(RootBeanDefinition beanDefinition) {
            super(beanDefinition);
        }

        /**
         * MethodOverrideCallbackFilter 实现 CallbackFilter 的 #accept(Method method) 方法，
         * 根据 BeanDefinition 中定义的 MethodOverride 不同，返回不同的值， 这里返回的 PASSTHROUGH 、LOOKUP_OVERRIDE、
         * METHOD_REPLACER 都是 Callback 数组的下标，这里对应的数组为 CALLBACK_TYPES 数组，
         */
        @Override
        public int accept(Method method) {
            MethodOverride methodOverride = getBeanDefinition().getMethodOverrides().getOverride(method);
            if (logger.isTraceEnabled()) {
                logger.trace("Override for '" + method.getName() + "' is [" + methodOverride + "]");
            }
            if (methodOverride == null) {
                return PASSTHROUGH;
            } else if (methodOverride instanceof LookupOverride) {
                return LOOKUP_OVERRIDE;
            } else if (methodOverride instanceof ReplaceOverride) {
                return METHOD_REPLACER;
            }
            throw new UnsupportedOperationException("Unexpected MethodOverride subclass: " +
                    methodOverride.getClass().getName());
        }
    }


    /**
     * CGLIB MethodInterceptor to override methods, replacing them with an
     * implementation that returns a bean looked up in the container.
     */
    private static class LookupOverrideMethodInterceptor extends CglibIdentitySupport implements MethodInterceptor {

        private final BeanFactory owner;

        public LookupOverrideMethodInterceptor(RootBeanDefinition beanDefinition, BeanFactory owner) {
            super(beanDefinition);
            this.owner = owner;
        }

        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {
            // Cast is safe, as CallbackFilter filters are used selectively.
            // 获得 method 对应的 LookupOverride 对象
            LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);
            Assert.state(lo != null, "LookupOverride not found");
            // 获得参数,if no-arg, don't insist on args at all
            Object[] argsToUse = (args.length > 0 ? args : null);
            // 获得 Bean
            if (StringUtils.hasText(lo.getBeanName())) {
                // Bean 的名字
                return (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :
                        this.owner.getBean(lo.getBeanName()));
            } else { // Bean 的类型
                return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) :
                        this.owner.getBean(method.getReturnType()));
            }
        }
    }


    /**
     * CGLIB MethodInterceptor to override methods, replacing them with a call
     * to a generic MethodReplacer.
     */
    private static class ReplaceOverrideMethodInterceptor extends CglibIdentitySupport implements MethodInterceptor {

        private final BeanFactory owner;

        public ReplaceOverrideMethodInterceptor(RootBeanDefinition beanDefinition, BeanFactory owner) {
            super(beanDefinition);
            this.owner = owner;
        }

        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {
            // 获得 method 对应的 LookupOverride 对象
            ReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);
            Assert.state(ro != null, "ReplaceOverride not found");
            // TODO could cache if a singleton for minor performance optimization
            // 获得 MethodReplacer 对象
            MethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);
            // 执行替换
            return mr.reimplement(obj, method, args);
        }
    }

}
