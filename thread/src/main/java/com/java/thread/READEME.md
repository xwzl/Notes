# 1.线程专业术语  
    
    非线程安全：非线程安全主要是指多个线程对同一个对象中的 同一个变量实例变量进行操作是会出现值被更改，值不同步的情况，进而影响程序的执行流程。
    
    在Java中有三种方法可以终止正在运行的线程：
      1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
      2.使用stop方法强行终止线程，但是不推荐使用这个方法，因为Stop和Susped及resume一样，都是过期作废的方法，使用它们可能产生不可预料的结果。
      3.使用interrupt方法中断线程，但是interrupt方法不像for-break的使用效果那么明显，马上就停止循环。调用interrupt方法仅仅是在当前线程中打了一个停止标记，并不是真的停止线程。
    
    yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但是放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。
    非线程安全其实就算是多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是脏读，取到的数据是被改过得数据，而线程安全就是获得是实例变量的值经过同步处理的。
    
    
    某个线程中创建的新线程优先级与是否为守护线程，与创建的这个线程的线程属性一致。
    When code running in some thread creates a new <code>Thread</code> object, the new thread has its priority initially set equal to the priority 
    of the creating thread, and is a daemon thread if and only if the  creating thread is a daemon.
    
# 2.非线程安全仅针对实例变量，对方法内部的变量不做比较，因为方法内部的变量是私有的。
    
    静态方法锁或者同步代码块指针对类，不针对实例变量，实例变量的锁和类的锁不是同一把锁
    简单来说，只要针对的不是同一实例变量，且加锁的对象不相同，程序就是异步运行，仅针对同步方法和同步代码块。
# 3.volatile关键字的作用是强制从公共堆栈中获取变量的值，而不是从线程私有数据栈中获取变量的值。
    volatile关键字的作用是使变量在多线程间可见。
    
    使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile关键字最致命的缺点是不支持原子性:
      1.关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile执行修饰变量，而synchronized
    可以修饰方法。以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized的比率还是
    比较大的。
      2.多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。
      3.volatile保证了数据的可见性，但不保证原子性。而synchronized可以保证原子性，也可以间接保证可见性。因为它会将私有内存和公共内存中
    的数据做同步。
      4.再次重申一次，关键字volatile是解决变量在多个线程之间的可见性。而synchronized关键字解决的是多个线程之间访问资源的同步性。
    线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确定线程安全的。
    
    如果对于测试的变量值count1,在测试方法中加了synchronized关键字，变量前面就不用加volatile关键字
    关键字volatile主要使用场合是在多个线程中可以感知实例变量被更改了，并且可以获得最新的值使用，也就是多线程读取
    共享变量时可以获取最新值使用。
    关键字volatie提示线程每次从共享内存中读取变量，而不是从私有内存中读取变量，这样就保证了同步数据的可见性。
    但在这里需要注意的是：如果实例变量中的数据，比如i++,也就是i+=1;这样的操作其实并不是一个原子操作，就是非线程安
    全的，表示i++的操作步骤分解如下：
      1.从内存中取出i的值。
      2.计算i的值。
      3.将i的值写到内存中。
    假如在第二步计算过程中，另外一个线程也修了i的值，这个时候就出现了脏读（脏读就是指当一个事务正在访问数据，并且对
    数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数
    据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的）。解决方法就是
    使用synchronized,所以volatile本身不处理数据的原子性，而是强制对数据的读写及时响应到主机内存中。
      