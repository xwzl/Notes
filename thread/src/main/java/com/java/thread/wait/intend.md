 # 1.基本概念   
    线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。
    线程的通信就是成为整体的必用方案之一。
    线程间通信进行通信后，系统之间的交互性会更大，在大大提高cpu利用率的同时还会使
    程序员对个线程任务在处理的
    过程中进行有效的把控与监督。
    
    wait和notify必须在同步代码块或者方法中执行。
    
    执行到wait方法后，程序立即退出方法并释放对象锁。
    执行notify方法后，不会立即退出方法，执行完同步代码块的代码之后才会释放对象锁。

#2.线程状态切换
&nbsp;&nbsp;日志信息 wait end在最后输出,这也说明 notify方法执行后并不立即释放锁。<br>
&nbsp;&nbsp;关键字synchronized可以将任何一个Object对象作为同步对象来看待,而Java为每个Object都实现了wait和notify方法.
它们必须用在被 synchronized同步的Object的临界区内。通过调用wait()方法可以使处于临界区内的线程进入等待状态,同时释
放被同步对象的锁。而notify操作可以唤醒一个因调用了wait操作而处于阻塞状态中的线程,使其进入就绪状态。被重新换醒的
线程会试图重新获得临界区的控制权,也就是锁,并继续执行临界区内wait之后的代码。如
果发出notify操作时没有处于阻塞状态中的线程,那么该命令会被忽略.<br>
&nbsp;&nbsp;wait()方法可以使调用该方法的线程释放共享资源的锁,然后从运行状态退出,进入等待队列,直到被再次唤醒。
&nbsp;&nbsp;notify()方法可以随机唤醒等待队列中等待同一共享资源的“一个”线程,并使该线程退出等待队列,进入可运行状态,也就是notify方法仅通知“一个”线程。
&nbsp;&nbsp;notifyAll()方法可以使所有正在等待队列中等待同一共享资源的“全部”线程从等待状
态退出,进入可运行状态。此时,优先级最高的那个线程最先执行,但也有可能是随机执
行，因为这要取决于JWM虚拟机的实现。
&nbsp;&nbsp;在前面的章节中已经介绍了与 Thread有关的大部分API,这些API可以改变线程
的状态.
![com/java/thread/wait/W.png](com/java/thread/pool/images/W.png)
 1) 创建一个新的线程对象后,再调用它的star()方法,系统会为此线程分配CPU资
源,使其处于 Runnable(可运行)状态,这是一个准备运行的阶段。如果线程抢占到CPU资
源,此线程就处于 Running(运行)状态。
  2) Runnable状态和 Running状态可相互切换,因为有可能线程运行一段时间后,有其
他高优先级的线程抢占了CPU资源,这时此线程就从 Running状态变成 Runnable状态<br>
线程进入Runnable状态大体分为如下5种情况<br>
    口调用seeo方法后经过的时间超过了指定的休眠时间。<br>
    口线程调用的阻塞1O已经返回,阻塞方法执行完毕。<br>
    口线程成功地获得了试图同步的监视器。<br>
    口线程正在等待某个通知,其他线程发出了通知。<br>
    口处于挂起状态的线程调用了 resume 1复方法。<br>
3) Blocked是阻塞的意思,例如遇到了一个IO操作,此时CPU处于空闲状态,可能会
转而把CPU时间片分配给其他线程,这时也可以称为“暂停”状态。 Blocked状态结束后,
进入 Runnable状态,等待系统重新分配资源。<br>
出现阻塞的情况大体分为如下5种<br>
    口线程调用sep方法,主动放弃占用的处理器资源。<br>
    口线程调用了阻塞式Io方法,在该方法返回前,该线程被阻塞。<br>
    口线程试图获得一个同步监视器,但该同步监视器正被其他线程所持有。<br>
    口线程等待某个通知<br>
    口程序调用了 suspend方法将该线程挂起。此方法容易导致死锁,尽量避免使用该方法。<br>
4) runO方法运行结束后进入销毁阶段,整个线程执行完毕。<br>
   每个锁对象都有两个队列,一个是就绪队列,一个是阻塞队列。就绪队列存储了将要获
得锁的线程,阻塞队列存储了被阻塞的线程。一个线程被唤醒后,才会进入就绪队列,等待
CPU的调度;反之,一个线程被wait后,就会进入阻塞队列,等待下一次被唤醒

## 5.static 所有线程数据共享 ThreadLocal表示单独线程数据共享

